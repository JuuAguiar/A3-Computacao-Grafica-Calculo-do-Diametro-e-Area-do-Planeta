// This GUI file is generated by guibuilder version 4.2.1
//////////
f=figure('figure_position',[414,157],'figure_size',[640,673],'auto_resize','on','background',[33],'figure_name','Processamento de Imagens e Análise de Planetas','dockable','off','infobar_visible','off','toolbar_visible','off','menubar_visible','off','default_axes','on','visible','off');
//////////
handles.dummy = 0;
handles.btn1=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','center','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.1353205,0.16,0.23,0.1],'Relief','default','SliderStep',[0.01,0.1],'String','Carregar Imagem','Style','pushbutton','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','btn1','Callback','btn1_callback(handles)')
handles.Axes_Cinza= newaxes();handles.Axes_Cinza.margins = [ 0 0 0 0];handles.Axes_Cinza.axes_bounds = [0.1,0.05,0.3,0.25];
handles.Axes_Binario= newaxes();handles.Axes_Binario.margins = [ 0 0 0 0];handles.Axes_Binario.axes_bounds = [0.6,0.05,0.3,0.25];
handles.btn_diametro=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','center','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.6353045,0.16,0.23,0.1],'Relief','default','SliderStep',[0.01,0.1],'String','Calcular','Style','pushbutton','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','btn_diametro','Callback','btn_diametro_callback(handles)')
handles.Axes_Original= newaxes();handles.Axes_Original.margins = [ 0 0 0 0];handles.Axes_Original.axes_bounds = [0.1,0.47,0.3,0.2];
handles.sld_bin=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.6,0.65,0.3,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','slider','Style','slider','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','sld_bin','Callback','sld_bin_callback(handles)')
handles.txt_result=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.6108814,0.4,0.2788462,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_result','Callback','')
handles.txt_frame=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.610609,0.4421293,0.2788462,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_frame','Callback','')
handles.sld_x=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.0416667,0.6987382,0.0528846,0.2570978],'Relief','default','SliderStep',[0.01,0.1],'String','UnName10','Style','slider','Value',[1],'VerticalAlignment','middle','Visible','on','Tag','sld_x','Callback','sld_x_callback(handles)')
handles.sld_y=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.1012821,0.6561514,0.2980769,0.0425868],'Relief','default','SliderStep',[0.01,0.1],'String','UnName11','Style','slider','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','sld_y','Callback','sld_y_callback(handles)')
handles.txt_escala=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.610609,0.5329968,0.2788462,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','Escala Km/pixel','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_escala','Callback','')
handles.edt_escala=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.7616026,0.5329968,0.1270513,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','edit','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','edt_escala','Callback','')
handles.edt_bin=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.5988462,0.5998423,0.0689103,0.0504732],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','edit','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','edt_bin','Callback','edt_bin_callback()')
handles.txt_resultinfo=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.610609,0.34653,0.2788462,0.06],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_resultinfo','Callback','')
handles.txt_contador=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.610609,0.4842587,0.2788462,0.05],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_contador','Callback','')
handles.txt_volume=uicontrol(f,'unit','normalized','BackgroundColor',[-1,-1,-1],'Enable','on','FontAngle','normal','FontName','Tahoma','FontSize',[12],'FontUnits','points','FontWeight','normal','ForegroundColor',[-1,-1,-1],'HorizontalAlignment','left','ListboxTop',[],'Max',[1],'Min',[0],'Position',[0.610609,0.3012618,0.2788462,0.055],'Relief','default','SliderStep',[0.01,0.1],'String','','Style','text','Value',[0],'VerticalAlignment','middle','Visible','on','Tag','txt_volume','Callback','')


f.visible = "on";


//////////
// Callbacks are defined as below. Please do not delete the comments as it will be used in coming version
//////////




///////////////////////////////////////////////////
// Disciplina: Computação Gráfica
// Aula prática - 2025_1
// Programa: Interface GUI BUILDER - Processamento de Imagens
// Turma: UNA - Cristiano Machado - Manhã - 14/05
// Integrantes: Isaac Penaforte
//              Júlia Aguiar
//              Lucas Ferreira
//////////////////////////////////////////////////

clc; // Limpa console

f.UserData = handles;// Permite armazenar imagens do eixo "handles" 
                     // em UserData para uso em funções  


global Im1 Im2 im_binaria im_cortada; // Define variáveis como globais para visualização no navegador de variáveis

function btn1_callback(handles)
//Write your callback for  btn1  here
    global Im1 Im2;
    
    limpar_frames(handles); // Limpa os Axes de imagens anteriores
    visibilidade(handles,"off"); // Torna os campos e Axes invisíveis até selecionar uma imagem válida
    f = gcf();// Recebe manipulador da interface
    handles = f.UserData; // Recupera imagens armazenadas em UserData
    
    [ImNome,caminho] = uigetfile(); // Recebe uma imagem do navegador de arquivos
    Im1 = imread(fullfile(caminho,ImNome)); // Lê e armazena uma imagem
    handles.nome_original = ImNome; // Armazena o nome da imagem
    
    visibilidade(handles,"on"); // Mostra os Axes e campos
    
    handles.ImOriginal = Im1; // Armazena a imagem original
    sca(handles.Axes_Original); // Seleciona um Axes para plot
    imshow(Im1);replot(); // Apresenta imagem e a redimensiona para encaixar no Axes
    title(handles.nome_original); // Titulo da imagem

    sca(handles.Axes_Cinza);  // Seleciona um Axes para plot
    Im2 = rgb2gray(Im1); // Transforma imagem generica para escala de cinza
    handles.Im2 = Im2;   // Armazena Im2 no handles
    imshow(Im2);replot(); // Apresenta imagem e a redimensiona para encaixar no Axes
    title("Imagem Tons de Cinza"); // Titulo imagem
    
    f.UserData = handles; // Armazena dados/imagens em UserData
    sld_bin_callback(handles);

endfunction

function btn_diametro_callback(handles)
//Write your callback for  btn_diametro  here

    escala = strtod(handles.edt_escala.String); // Recebe o campo da escala de KM/pixel do usuário como valor numérico
    if isnan(escala) then // Se não for um valor válido exibe erro e para a função
        messagebox("Preencha o campo de escala com um valor válido!","Aviso","warning");
        return;
    end
    handles.txt_frame.String = 'Resultado: Carregando.'; // Apresenta a mensagem na interface
    handles.txt_result.String = ''; // Deixa vazio o campo resultado
    editaveis(handles,'off'); // Desativa recursos da interface
    
    f = gcf(); // Recebe manipulador da interface
    handles = f.UserData; // Recupera imagens armazenadas em UserData
    im_binaria = handles.im_binaria; // Aponta para a imagem binária no handles
    
    [rows, cols] = size(im_binaria); // Recebe quantidade de linhas e colunas da imagem
  
    pos_central_coluna = round(cols/2);  // Divide colunas para ter o valor central da imagem
    pos_central_linha = round(rows/2);   // Divide linhas para ter o valor central da imagem
    contador = 0;  // Quantidade de pixels brancos contabilizados
    
    
    for j = 1:pos_central_coluna // Percorre a linha até o centro da imagem
        
        pixel = im_binaria(pos_central_linha, j); // Define pixel a posicao atual na matriz
        
        if pixel == %T then // Se pixel for branco o contador aumenta
            contador=contador+1; // Contador de pixels brancos
        end
    end
    
    if contador ~= 0 then  // Se detectar pixels brancos, calcula raio e diametro
        raio=contador;
    else            // Se não encontrar, envia um aviso e retorna
        messagebox("Nenhum pixel detectado!","Aviso","warning");
        editaveis(handles,'on'); // Permite o uso da interface novamente
        return
    end
    
    
    raio = raio * escala;// Calcula o valor do raio multiplicando o contador pela escala
    diametro= raio * 2;// Calcula o diametro
    area_superficie = 4*%pi*raio^2; // Calcula a área da superfície
    volume = (4*%pi*raio^3)/3; // Calcula o volume
    
    msg_contador = strcat(['Contagem de pixels: ',string(contador)]); // Define a mensagem que representa o contador de pixels
    msg_raio = strcat(['Raio: ',string(raio),' quilômetros']);// Define a mensagem que representa o raio
    msg_diametro = strcat(['Diâmetro: ',string(diametro),' quilômetros']); // Define a mensagem que representa o diametro
    msg_area = strcat(['Área superfície: ',string(area_superficie),' km²']); // Define a mensagem que representa o diametro
    msg_volume = strcat(['Volume: ',string(volume),' km³']);// Define a mensagem que representa o volume
    
    handles.txt_frame.String = msg_raio; // Apresenta o raio do planeta
    handles.txt_result.String = msg_diametro; // Apresenta o diametro na interface
    handles.txt_resultinfo.String = msg_area; // Apresenta a área da superfície do planeta
    handles.txt_volume.String = msg_volume; // Apresenta o volume do planeta
    handles.txt_contador.String = msg_contador; // Apresenta o contador na interface

    
    editaveis(handles,'on'); // Permite o uso da interface novamente
    
    f.UserData = handles; // Armazena dados/imagens em UserData
    
endfunction

function atualizar_imbin(handles) // Gera nova imagem binária
    global im_binaria;
    f = gcf(); // Recebe manipulador da interface
    handles = f.UserData; // Recupera imagens armazenadas em UserData
    
    delete(handles.Axes_Binario.children); // Remove a imagem binária anterior
    im_binaria = im2bw(handles.Im2,handles.bin_treshhold); // Gera imagem binária da imagem em escala de cinza
    handles.im_binaria = im_binaria; // Armazena imagem binária em handles
    sca(handles.Axes_Binario); // Seleciona um Axes para plot
    imshow(im_binaria);replot(); // Apresenta imagem e a redimensiona para encaixar no Axes
    title("Imagem Binária"); // Da titulo a imagem
    
    f.UserData = handles; // Armazena dados/imagens em UserData
endfunction

function atualizar_corte(handles) // Corta a iamgem em escala de cinza
    global im_cortada;
    f = gcf(); // Recebe manipulador da interface
    handles = f.UserData; // Recupera imagens armazenadas em UserData

    im = handles.ImOriginal; // Recebe a imagem original
    [altura, largura] = size(im); // Armazena as linhas e colunas da imagem

    // Normaliza os sliders entre 1 até altura/largura
    x1 = round(handles.sld_x.value * (altura - 1)) + 1;
    y1 = round(handles.sld_x.value * (largura - 1)) + 1;

    x2 = round(handles.sld_y.value * (altura - 1)) + 1;
    y2 = round(handles.sld_y.value * (largura - 1)) + 1;
    
    // Corrige o corte da imagem em caso de inversão de valores/sliders
    // para em im(x1:x2,y1:y2) x1 ou y1 não seja maior que x2 ou y2 respectivamente
    if x1 > x2 then
        temp = x1; // Armazena x1 em temp
        x1 = x2; // x1 recebe o valor menor
        x2 = temp; // x2 recebe o valor maior em temp
    end
    if y1 > y2 then
        temp = y1; // Armazena y1 em temp
        y1 = y2; // y1 recebe o valor menor
        y2 = temp; // y2 recebe o valor maior em temp
    end
    
    // Corta a imagem e a retorna como Im2 
    im_cortada = im(x1:x2, y1:y2);
    handles.Im2 = im_cortada;

    delete(handles.Axes_Cinza.children); // Limpa a imagem antiga
    sca(handles.Axes_Cinza); // Recebe o Axes1 como referencia
    imshow(im_cortada);replot(); // Plota a imagem cortada e a reajusta no Axes

    f.UserData = handles; // Armazena dados/imagens em UserData
    sld_bin_callback(handles); // Atualiza e gera nova imagem binária com a imagem recortada
    
endfunction

function sld_x_callback(handles) // Callback do slider de corte de imagem
//Write your callback for  sld_x  here
    atualizar_corte(handles);
endfunction

function sld_y_callback(handles) // Callback do slider de corte de imagem
//Write your callback for  sld_x2  here
    atualizar_corte(handles);
endfunction


function sld_bin_callback(handles) // Callback do slider do valor limite binário
//Write your callback for  sld_bin  here
    f = gcf(); // Recebe manipulador da interface
    handles = f.UserData;   // Recupera imagens armazenadas em UserData
    
    handles.edt_bin.String = string(handles.sld_bin.value); // Campo editavel recebe valor do slider
    handles.bin_treshhold = handles.sld_bin.value;   // Atualiza novo valor limite binário
    
    f.UserData = handles;
    atualizar_imbin(handles); // Atualiza imagem binária com novo valor limite
    
endfunction

function edt_bin_callback(handles) // Callback do campo de texto do valor limite binário
    f = gcf(); // Recebe manipulador da interface
    handles = f.UserData;   // Recupera imagens armazenadas em UserData
    if isempty(handles.edt_bin.String) then
        return;
    end
    
    handles.sld_bin.value = strtod(handles.edt_bin.String); // Slider recebe valor do campo editavel
    handles.bin_treshhold = strtod(handles.edt_bin.String); // Atualiza novo valor limite binário
    
    f.UserData = handles; // Armazena dados/imagens em UserData
    
    atualizar_imbin(handles); // Atualiza imagem binária com novo valor limite
     
endfunction

function limpar_frames(handles) // Limpa todos os Axes e redefine valores
    
    axes_list = list("Axes_Cinza","Axes_Binario","Axes_Original"); // Lista de Axes utilizados 
    
    for i = 1:length(axes_list); // Seleciona cada Axes da lista e apaga o conteudo
        
        execstr("delete(handles." + axes_list(i) + ".children);"); // Executa como código a string 
        
    end
    
    // Retorna os valores padrões de sliders e campos
    handles.sld_x.value = 1;
    handles.sld_y.value = 0;
    handles.sld_bin.value = 0.1;
    handles.txt_result.String = '';
    handles.txt_resultinfo.String = '';
    handles.txt_volume.String = '';
    handles.txt_contador.String = '';
    handles.txt_frame.String = '';
    handles.edt_escala.String = '';
endfunction

// Altera a visibilidade dos itens da interface
function visibilidade(handles,modo) 
    // modo = 'on' ou 'off'
    
    handles.btn_diametro.visible = modo;
    handles.btn_volume.visible = modo;
    handles.txt_result.visible = modo;
    handles.txt_resultinfo.visible = modo;
    handles.txt_volume.visible = modo;
    handles.txt_frame.visible = modo;
    handles.txt_contador.visible = modo;
    handles.Axes_Cinza.visible = modo;
    handles.Axes_Binario.visible = modo;
    
    handles.sld_x.visible = modo;
    handles.sld_y.visible = modo;
    
    handles.sld_bin.visible = modo;
    handles.edt_bin.visible = modo;
    
    handles.edt_escala.visible = modo;
    handles.txt_escala.visible = modo;
    
    
endfunction

// Desativa sliders, botões e campos
function editaveis(handles,modo)
    // modo = 'on' ou 'off'
    
    handles.sld_x.Enable = modo;
    handles.sld_y.Enable = modo;
    handles.sld_bin.Enable = modo;
    handles.edt_escala.Enable = modo;
    handles.edt_bin.Enable = modo;
    handles.btn_diametro.Enable = modo;
    handles.btn1.Enable = modo;
    
endfunction

visibilidade(handles,"off"); // Inicia o programa com os campos e Axes invisíveis

// Anotações -----------------
//
//  Para o calculo do diametro correto, o planeta deve permanecer no centro do campo Axes,
//  se necessário, cortando a imagem utilizando os sliders para evitar objetos/areas que não
//  fazem parte da area de interesse. 
//  A escala deve ser definida antes de realizar o calculo, conferir fonte.
//
// f.UserData = handles:
// Permite armazenar imagens do eixo "handles" 
// em UserData para uso em funções  
//  
//  rgb2gray: Transforma uma imagem para escala de cinza
//  uigetfile: Recebe imagem do explorador de arquivos
//  sca: Seleciona um Axe específico para plot
//  
//  Cada elemento na interface possui atributos como visible e enable que
//  permitem a alteração de sua aparencia e uso na interface, devem ser modificados
//  para evitar interações indevidas e bugs utilizando as funções "editaveis" e "visibilidade"
//  
//  delete: remove do Axes selecionado a imagem ocupada
////////////////


